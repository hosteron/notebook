0-/dev/stdin-标准输入 1-/dev/stdout-标准输出 2-/dev/stderr-标准错误
shell脚本中的exec命令：
exec后面跟着的是文件描述符的话先不谈
exec后面跟着的是shell命令，此命令结束后，shell也结束了
shell脚本中各种括号的用法:
http://blog.csdn.net/taiyang1987912/article/details/39551385

shell脚本中的find 命令的用法:
http://man.linuxde.net/find
例子：
find . -maxdepth 1 -type d ! \( -name alsa -o -name terminfo -o -name . \)  -exec rm -fr {} \;
-maxdepth:最大深度　1
-type:搜索的文件类型　d　目录
	f　普通文件
	l　符号链接
	d　目录
	c　字符设备
	b　块设备
	s　嵌套字
	p　Fifo
!: 否定参数
\( -name alsa -o -name terminfo -o -name . \):因为括号在ｓｈｅｌｌ脚本中有命令组的含义，需要转义，-o表示条件或
-exec 根据搜索后的结果直接后面的命令
rm -fr {}:这里的{}表示搜索出来的所有结果

/////
tar --owner=0 --group=0:
--group=group
  备份时，把加入备份文件中的文件所属组设定成指定的组
--owner=owner
  备份时，把把加入备份文件中的文件所有者设定成指定的用户

///////
wc -c 显示字符数，-l 显示函数,-m显示字符数（只有在文件中有非ascii外的编码数据，输出的结果才和-c的结果不一致）,-w显示单词数，-L显示最长一行的字符数

//////
$*与$@变量都提供了对所有参数的快速访问，这两个都能够在单个变量中存储所有的命令行参数。

$*变量会将命令行上提供的所有参数当作单个单词保存，其会被当作单个参数，而不是多个对象。

$@变量会将命令行上提供的所有参数当作同意个字符串中的多个独立的单词。他允许遍历所有的值，将提供的每个参数分割开来。这通常通过for命令完成。

/////
xargs
http://man.linuxde.net/xargs

////
&& -> command1&&command2&&command3,在前一个命令执行成功时，后面的命令才能正常执行
|| -> command1||command2||command3,在前一个命令执行失败时，后面的命令才能正常执行
() -> 括号中的命令用';'分割开,命令是在子shell中执行的，不会对当前的shell影响
{} -> '{','}'和命令之间用用空格分割开，命令之间用';'分开，其中命令会对当前的shell影响

////
对于错误定位的一些方法的blog地址
https://www.cnblogs.com/panfeng412/archive/2011/11/06/2237857.html
